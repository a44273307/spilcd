C51 COMPILER V9.05   MAIN                                                                  05/06/2023 21:37:33 PAGE 1   


C51 COMPILER V9.05, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c LARGE BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include "STC8G.h"
   2          #include <intrins.h>
   3          #include <stdio.h>
   4          #include "lcd.h"
   5          #define u8 unsigned char
   6          #define FOSC 11059200UL
   7          #define BRT (65536 - FOSC / 9600 / 4)
   8          bit busy;
   9          void UartInit() // 11.0592 9600
  10          {
  11   1              SCON = 0x50;  // 8位数据,可变波特率
  12   1              AUXR |= 0x40; // 定时器时钟1T模式
  13   1              AUXR &= 0xFE; // 串口1选择定时器1为波特率发生器
  14   1              TMOD &= 0x0F; // 设置定时器模式
  15   1              TL1 = 0xE0;       // 设置定时初始值
  16   1              TH1 = 0xFE;       // 设置定时初始值
  17   1              ET1 = 0;          // 禁止定时器%d中断
  18   1              TR1 = 1;          // 定时器1开始计时
  19   1              ES = 1;
  20   1              EA = 1;
  21   1              P_SW1 = 0x00; // RXD/P3.0, TXD/P3.1
  22   1              //  P_SW1 = 0x40;                               //RXD_2/P3.6, TXD_2/P3.7
  23   1              //  P_SW1 = 0x80;                               //RXD_3/P1.6, TXD_3/P1.7
  24   1              //      PS=1;
  25   1      }
  26          void UartSendByte(u8 dat)
  27          {
  28   1              SBUF = dat;
  29   1              while (TI == 0)
  30   1                      ;
  31   1              TI = 0;
  32   1      }
  33          char putchar (char dat)
  34          {
  35   1              SBUF = dat;
  36   1              while (TI == 0)
  37   1                      ;
  38   1              TI = 0;
  39   1              return (SBUF = dat);
  40   1      }
  41          
  42          void UartSendStr(u8 *str)
  43          {
  44   1              while (*str)
  45   1              {
  46   2                      UartSendByte(*str);
  47   2                      str++;
  48   2              }
  49   1      }
  50          void Uart2Init()
  51          {
  52   1              S2CON = 0x10;
  53   1              T2L = BRT;
  54   1              T2H = BRT >> 8;
  55   1              AUXR |= 0x14;
C51 COMPILER V9.05   MAIN                                                                  05/06/2023 21:37:33 PAGE 2   

  56   1              IE2 = 0x01;
  57   1              EA = 1;
  58   1      }
  59          void Uart2Send(char dat)
  60          {
  61   1              while (busy)
  62   1                      ;
  63   1              busy = 1;
  64   1              S2BUF = dat;
  65   1      }
  66          
  67          void Uart2SendStr(char *p)
  68          {
  69   1              while (*p)
  70   1              {
  71   2                      Uart2Send(*p++);
  72   2              }
  73   1      }
  74          
  75          
  76          void Timer0Init(void) // 2毫秒@11.0592MHz
  77          {
  78   1              AUXR |= 0x80; // 定时器时钟1T模式
  79   1              TMOD &= 0xF0; // 设置定时器模式
  80   1              TL0 = 0x9a;       // 设置定时初值
  81   1              TH0 = 0xa9;       // 设置定时初值
  82   1              TF0 = 0;          // 清除TF0标志
  83   1              TR0 = 1;          // 定时器0开始计时
  84   1              TR0 = 1;          // 定时器0开始计时
  85   1              ET0 = 1;          // 使能定时器0中断
  86   1              PT0 = 1;
  87   1              EA = 1;
  88   1              //    IT0 = 1;                                    //??INT0?????
  89   1              //    EX0 = 1;                                    //??INT0??
  90   1              //    EA = 1;
  91   1              //
  92   1              //      IT1 = 1;                                    //??INT1?????
  93   1              //    EX1 = 1;                                    //??INT1??
  94   1              //    EA = 1;
  95   1      }
  96          
  97          
  98          
  99          
 100          
 101          #define DATA_H P2
 102          #define DATA_L P0
 103          sbit LCD_LED= P1^1;
 104          
 105          sbit LCD_CS = P1^2;
 106          sbit LCD_CD = P1^0;//就是TFT上的LCD_WR引脚
 107          sbit LCD_RESET = P0^3;
 108          ////sbit LCD_MOSI = P1^4;
 109          ////sbit LCD_MISO = P1^3;
 110          //sbit LCD_SCK = P1^5;//就是TFT上的LCD_RS引脚
 111          
 112          void Delay1ms()         //@12.000MHz
 113          {
 114   1              unsigned char i, j;
 115   1      
 116   1              i = 12;
 117   1              j = 169;
C51 COMPILER V9.05   MAIN                                                                  05/06/2023 21:37:33 PAGE 3   

 118   1              do
 119   1              {
 120   2                      while (--j);
 121   2              } while (--i);
 122   1      }
 123          
 124          void delay_ms(unsigned int ms)
 125          {
 126   1              while(ms--)
 127   1              {
 128   2                      Delay1ms();
 129   2              }
 130   1      }
 131          
 132          void SPI_RW(unsigned char byte)
 133          {
 134   1              SPDAT = byte;                           //??????
 135   1        while (!(SPSTAT & 0x80));               //??????
 136   1        SPSTAT = 0xc0;                          //?????
 137   1              
 138   1      //      for(bit_ctr=0;bit_ctr<8;bit_ctr++) // 输出8位
 139   1      //      {
 140   1      //              LCD_SCK=0;
 141   1      //              LCD_MOSI=(byte&0x80); // MSB TO MOSI
 142   1      //              byte=(byte<<1); // shift next bit to MSB
 143   1      //              LCD_SCK=1;
 144   1      //              byte|=LCD_MISO;         // capture current MISO bit
 145   1      //      }
 146   1      //      return byte;
 147   1              
 148   1      }
 149          
 150          void LCD_CD_DATA(unsigned char val)
 151          {
 152   1              LCD_CS=0;
 153   1              LCD_CD=1;
 154   1              SPI_RW(val);
 155   1              LCD_CS=1;
 156   1      }
 157          
 158          void LCD_CD_REG(unsigned char reg)
 159          {
 160   1              LCD_CS=0;
 161   1              LCD_CD=0;
 162   1              SPI_RW(reg);
 163   1              LCD_CS=1;
 164   1      }
 165          int USE_HORIZONTAL=0;
 166          void LCD_Init()
 167          {
 168   1              LCD_RESET=0;
 169   1              delay_ms(10);
 170   1              LCD_RESET=1;
 171   1      
 172   1      
 173   1              LCD_WR_REG(0x11); //Sleep out 
 174   1              delay_ms(120);              //Delay 120ms 
 175   1              //************* Start Initial Sequence **********// 
 176   1              LCD_WR_REG(0xCF);
 177   1              LCD_WR_DATA8(0x00);
 178   1              LCD_WR_DATA8(0xC1);
 179   1              LCD_WR_DATA8(0X30);
C51 COMPILER V9.05   MAIN                                                                  05/06/2023 21:37:33 PAGE 4   

 180   1              LCD_WR_REG(0xED);
 181   1              LCD_WR_DATA8(0x64);
 182   1              LCD_WR_DATA8(0x03);
 183   1              LCD_WR_DATA8(0X12);
 184   1              LCD_WR_DATA8(0X81);
 185   1              LCD_WR_REG(0xE8);
 186   1              LCD_WR_DATA8(0x85);
 187   1              LCD_WR_DATA8(0x00);
 188   1              LCD_WR_DATA8(0x79);
 189   1              LCD_WR_REG(0xCB);
 190   1              LCD_WR_DATA8(0x39);
 191   1              LCD_WR_DATA8(0x2C);
 192   1              LCD_WR_DATA8(0x00);
 193   1              LCD_WR_DATA8(0x34);
 194   1              LCD_WR_DATA8(0x02);
 195   1              LCD_WR_REG(0xF7);
 196   1              LCD_WR_DATA8(0x20);
 197   1              LCD_WR_REG(0xEA);
 198   1              LCD_WR_DATA8(0x00);
 199   1              LCD_WR_DATA8(0x00);
 200   1              LCD_WR_REG(0xC0); //Power control
 201   1              LCD_WR_DATA8(0x1D); //VRH[5:0]
 202   1              LCD_WR_REG(0xC1); //Power control
 203   1              LCD_WR_DATA8(0x12); //SAP[2:0];BT[3:0]
 204   1              LCD_WR_REG(0xC5); //VCM control
 205   1              LCD_WR_DATA8(0x33);
 206   1              LCD_WR_DATA8(0x3F);
 207   1              LCD_WR_REG(0xC7); //VCM control
 208   1              LCD_WR_DATA8(0x92);
 209   1              LCD_WR_REG(0x3A); // Memory Access Control
 210   1              LCD_WR_DATA8(0x55);
 211   1              LCD_WR_REG(0x36); // Memory Access Control
 212   1              if(USE_HORIZONTAL==0)LCD_WR_DATA8(0x08);
 213   1              else if(USE_HORIZONTAL==1)LCD_WR_DATA8(0xC8);
 214   1              else if(USE_HORIZONTAL==2)LCD_WR_DATA8(0x78);
 215   1              else LCD_WR_DATA8(0xA8);
 216   1              LCD_WR_REG(0xB1);
 217   1              LCD_WR_DATA8(0x00);
 218   1              LCD_WR_DATA8(0x12);
 219   1              LCD_WR_REG(0xB6); // Display Function Control
 220   1              LCD_WR_DATA8(0x0A);
 221   1              LCD_WR_DATA8(0xA2);
 222   1      
 223   1              LCD_WR_REG(0x44);
 224   1              LCD_WR_DATA8(0x02);
 225   1      
 226   1              LCD_WR_REG(0xF2); // 3Gamma Function Disable
 227   1              LCD_WR_DATA8(0x00);
 228   1              LCD_WR_REG(0x26); //Gamma curve selected
 229   1              LCD_WR_DATA8(0x01);
 230   1              LCD_WR_REG(0xE0); //Set Gamma
 231   1              LCD_WR_DATA8(0x0F);
 232   1              LCD_WR_DATA8(0x22);
 233   1              LCD_WR_DATA8(0x1C);
 234   1              LCD_WR_DATA8(0x1B);
 235   1              LCD_WR_DATA8(0x08);
 236   1              LCD_WR_DATA8(0x0F);
 237   1              LCD_WR_DATA8(0x48);
 238   1              LCD_WR_DATA8(0xB8);
 239   1              LCD_WR_DATA8(0x34);
 240   1              LCD_WR_DATA8(0x05);
 241   1              LCD_WR_DATA8(0x0C);
C51 COMPILER V9.05   MAIN                                                                  05/06/2023 21:37:33 PAGE 5   

 242   1              LCD_WR_DATA8(0x09);
 243   1              LCD_WR_DATA8(0x0F);
 244   1              LCD_WR_DATA8(0x07);
 245   1              LCD_WR_DATA8(0x00);
 246   1              LCD_WR_REG(0XE1); //Set Gamma
 247   1              LCD_WR_DATA8(0x00);
 248   1              LCD_WR_DATA8(0x23);
 249   1              LCD_WR_DATA8(0x24);
 250   1              LCD_WR_DATA8(0x07);
 251   1              LCD_WR_DATA8(0x10);
 252   1              LCD_WR_DATA8(0x07);
 253   1              LCD_WR_DATA8(0x38);
 254   1              LCD_WR_DATA8(0x47);
 255   1              LCD_WR_DATA8(0x4B);
 256   1              LCD_WR_DATA8(0x0A);
 257   1              LCD_WR_DATA8(0x13);
 258   1              LCD_WR_DATA8(0x06);
 259   1              LCD_WR_DATA8(0x30);
 260   1              LCD_WR_DATA8(0x38);
 261   1              LCD_WR_DATA8(0x0F);
 262   1              LCD_WR_REG(0x29); //Display on
 263   1      }
 264          
 265          void LCD_SetArea(unsigned int stx,unsigned int sty,unsigned int endx,unsigned int endy)
 266          {
 267   1              LCD_CD_REG(0x2A);  
 268   1              LCD_CD_DATA(stx>>8);    
 269   1              LCD_CD_DATA(stx&0xff);          
 270   1              LCD_CD_DATA(endx>>8); 
 271   1              LCD_CD_DATA(endx&0xff); 
 272   1      
 273   1              LCD_CD_REG(0x2B);
 274   1              LCD_CD_DATA(sty>>8); 
 275   1              LCD_CD_DATA(sty&0xff);  
 276   1              LCD_CD_DATA(endy>>8); 
 277   1              LCD_CD_DATA(endy&0xff); 
 278   1      }
 279          
 280          void LcdWirteColorData(unsigned int color)
 281          {
 282   1              LCD_CS=0;
 283   1              LCD_CD=1;
 284   1              SPI_RW(color>>8);
 285   1              SPI_RW(color);
 286   1              LCD_CS=1;
 287   1      }
 288          
 289          void LCD_Clear(unsigned int color)
 290          {  
 291   1              unsigned int i,j;
 292   1      
 293   1              LCD_SetArea(0,0,239,319);
 294   1        LCD_CD_REG(0x2C);
 295   1              for(i=0;i<320;i++)
 296   1              {
 297   2                      for(j=0;j<240;j++)
 298   2                      {
 299   3                              LcdWirteColorData(color);
 300   3                      }
 301   2              }
 302   1      }
 303          sbit X0 = P2 ^ 3;
C51 COMPILER V9.05   MAIN                                                                  05/06/2023 21:37:33 PAGE 6   

 304          sbit X1 = P2 ^ 1;
 305          sbit X2 = P3 ^ 7;
 306          sbit X3 = P3 ^ 5;
 307          
 308          
 309          sbit LED0 = P3 ^ 4;
 310          char xin[30]={0};
 311          void shurulvbo(void)
 312          {
 313   1              static u8 keybuf[40] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
 314   1                                                         0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
 315   1                                                         0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
 316   1                                                                                                                                                               0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
 317   1                                                        }; //矩阵按键扫描缓冲区 8ms
 318   1              unsigned char i;
 319   1              // i=X0;
 320   1              // keybuf[0]=i;
 321   1              // i=X1;
 322   1              // keybuf[1]=i;
 323   1              //  i=X2;
 324   1              //  keybuf[2]=i;
 325   1              //   i=X3;
 326   1              //  keybuf[3]=i;
 327   1              i=X0;
 328   1              keybuf[0] = (keybuf[0] << 1) | i;
 329   1              i=X1;
 330   1              keybuf[1] = (keybuf[1] << 1) | i;
 331   1              i=X2;
 332   1              keybuf[2] = (keybuf[2] << 1) | i;
 333   1              i=X3;
 334   1              keybuf[3] = (keybuf[3] << 1) | i;
 335   1              for (i = 0; i < 10; i++) // 3按键，所以循环3次
 336   1              {
 337   2                      if ((keybuf[i] & 0xFF) == 0x00)
 338   2                      {
 339   3                              xin[i] = 0;
 340   3                      }
 341   2                      else if ((keybuf[i] & 0xFF) == 0xFF)
 342   2                      { // 连续3次扫描值为1，即1*8ms内都是弹起状态时，可认为按键已稳定的弹起
 343   3                              xin[i] = 1;
 344   3                      }
 345   2              }
 346   1      }
 347          void keydown(int i) // 按键按下的处理、、、
 348          {
 349   1              printf("keydown %d\r\n", i);
 350   1              if(i==0)
 351   1              {
 352   2                      LED0=~LED0;
 353   2              }
 354   1      }
 355          void keyallchuli()
 356          {
 357   1              int i;
 358   1              static int flag[10]={0};//标志记录
 359   1              for( i=0;i<6;i++)
 360   1              {
 361   2                      if(xin[i]==0)
 362   2                      {
 363   3                              if(flag[i]==0)//代表按键第一次按下。。。
 364   3                              {
 365   4                                      flag[i]=1;
C51 COMPILER V9.05   MAIN                                                                  05/06/2023 21:37:33 PAGE 7   

 366   4                                      keydown(i);
 367   4                              }
 368   3                      }
 369   2                      else 
 370   2                              flag[i]=0;
 371   2              }
 372   1      }
 373          #define LCD_W 240
 374          #define LCD_H 320
 375          
 376          void main()
 377          {
 378   1                P0M0 = 0x00;
 379   1          P0M1 = 0x02;
 380   1          P1M0 = 0x00;
 381   1          P1M1 = 0x00;
 382   1          P2M0 = 0x00;
 383   1          P2M1 = 0x00;
 384   1          P3M0 = 0x00;
 385   1          P3M1 = 0x00;
 386   1          P4M0 = 0x00;
 387   1          P4M1 = 0x00;
 388   1          P5M0 = 0x00;
 389   1          P5M1 = 0x00;
 390   1              
 391   1               SPCTL = 0x50|0x80;                               //??SPI????
 392   1          SPSTAT = 0xc0;                              //?????
 393   1              LCD_LED=0;
 394   1              delay_ms(100);
 395   1              
 396   1      //      SPI_Init();
 397   1              LCD_Init();
 398   1              // UartInit();
 399   1      
 400   1              // Timer0Init();
 401   1              delay_ms(100);
 402   1              // printf("123testruning");
 403   1              // printf("xxxx");
 404   1      
 405   1              LCD_Fill(0,0,LCD_W,LCD_H,WHITE);
 406   1              delay_ms(100);
 407   1              while(1)
 408   1              {
 409   2      
 410   2                      LCD_ShowChinese(0,0,"中景园电子",RED,WHITE,32,0);
 411   2                      LCD_ShowString(0,40,"LCD_W:",RED,WHITE,16,0);
 412   2                      LCD_ShowIntNum(48,40,LCD_W,3,RED,WHITE,16);
 413   2                      LCD_ShowString(80,40,"LCD_H:",RED,WHITE,16,0);
 414   2                      LCD_ShowIntNum(128,40,LCD_H,3,RED,WHITE,16);
 415   2                      LCD_ShowString(80,40,"LCD_H:",RED,WHITE,16,0);
 416   2                      LCD_ShowString(0,70,"Increaseing Nun:",RED,WHITE,16,0);
 417   2                      delay_ms(300);
 418   2                      // LCD_ShowString(0,40,"LCD_W:",RED,WHITE,16,0);
 419   2                      // shurulvbo();
 420   2                      // keyallchuli();
 421   2                      // delay_ms(2);
 422   2                      // LCD_Clear(WHITE);
 423   2                      // delay_ms(300);
 424   2                      // LCD_Clear(RED);
 425   2                      // delay_ms(300);
 426   2                      // LCD_Clear(BLUE);
 427   2                      // delay_ms(300);
C51 COMPILER V9.05   MAIN                                                                  05/06/2023 21:37:33 PAGE 8   

 428   2                      // LCD_Clear(GREEN);
 429   2                      // delay_ms(300);
 430   2                      // UartSendStr("123testruning");
 431   2              }
 432   1      }
 433          
 434          
 435          void UartIsr() interrupt 4
 436          {
 437   1      
 438   1              if (RI)
 439   1              {
 440   2                      RI = 0;
 441   2              }
 442   1      }
 443          
 444          void tm0_isr() interrupt 1
 445          {
 446   1              
 447   1      }
 448          
 449          
 450          
 451          
 452          
 453          
 454          
 455          
 456          
 457          
 458          
 459          
 460          
 461          
 462          
 463          
 464          
 465          
 466          
 467          
 468          
 469          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1525    ----
   CONSTANT SIZE    =     55    ----
   XDATA SIZE       =     92      19
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
