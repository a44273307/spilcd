C51 COMPILER V9.05   MAIN                                                                  05/06/2023 21:06:01 PAGE 1   


C51 COMPILER V9.05, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c LARGE BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include "STC8G.h"
   2          #include <intrins.h>
   3          #include <stdio.h>
   4          #define u8 unsigned char
   5          #define FOSC 11059200UL
   6          #define BRT (65536 - FOSC / 9600 / 4)
   7          bit busy;
   8          void UartInit() // 11.0592 9600
   9          {
  10   1              SCON = 0x50;  // 8位数据,可变波特率
  11   1              AUXR |= 0x40; // 定时器时钟1T模式
  12   1              AUXR &= 0xFE; // 串口1选择定时器1为波特率发生器
  13   1              TMOD &= 0x0F; // 设置定时器模式
  14   1              TL1 = 0xE0;       // 设置定时初始值
  15   1              TH1 = 0xFE;       // 设置定时初始值
  16   1              ET1 = 0;          // 禁止定时器%d中断
  17   1              TR1 = 1;          // 定时器1开始计时
  18   1              ES = 1;
  19   1              EA = 1;
  20   1              P_SW1 = 0x00; // RXD/P3.0, TXD/P3.1
  21   1              //  P_SW1 = 0x40;                               //RXD_2/P3.6, TXD_2/P3.7
  22   1              //  P_SW1 = 0x80;                               //RXD_3/P1.6, TXD_3/P1.7
  23   1              //      PS=1;
  24   1      }
  25          void UartSendByte(u8 dat)
  26          {
  27   1              SBUF = dat;
  28   1              while (TI == 0)
  29   1                      ;
  30   1              TI = 0;
  31   1      }
  32          char putchar (char dat)
  33          {
  34   1              SBUF = dat;
  35   1              while (TI == 0)
  36   1                      ;
  37   1              TI = 0;
  38   1              return (SBUF = dat);
  39   1      }
  40          
  41          void UartSendStr(u8 *str)
  42          {
  43   1              while (*str)
  44   1              {
  45   2                      UartSendByte(*str);
  46   2                      str++;
  47   2              }
  48   1      }
  49          void Uart2Init()
  50          {
  51   1              S2CON = 0x10;
  52   1              T2L = BRT;
  53   1              T2H = BRT >> 8;
  54   1              AUXR |= 0x14;
  55   1              IE2 = 0x01;
C51 COMPILER V9.05   MAIN                                                                  05/06/2023 21:06:01 PAGE 2   

  56   1              EA = 1;
  57   1      }
  58          void Uart2Send(char dat)
  59          {
  60   1              while (busy)
  61   1                      ;
  62   1              busy = 1;
  63   1              S2BUF = dat;
  64   1      }
  65          
  66          void Uart2SendStr(char *p)
  67          {
  68   1              while (*p)
  69   1              {
  70   2                      Uart2Send(*p++);
  71   2              }
  72   1      }
  73          
  74          
  75          void Timer0Init(void) // 2毫秒@11.0592MHz
  76          {
  77   1              AUXR |= 0x80; // 定时器时钟1T模式
  78   1              TMOD &= 0xF0; // 设置定时器模式
  79   1              TL0 = 0x9a;       // 设置定时初值
  80   1              TH0 = 0xa9;       // 设置定时初值
  81   1              TF0 = 0;          // 清除TF0标志
  82   1              TR0 = 1;          // 定时器0开始计时
  83   1              TR0 = 1;          // 定时器0开始计时
  84   1              ET0 = 1;          // 使能定时器0中断
  85   1              PT0 = 1;
  86   1              EA = 1;
  87   1              //    IT0 = 1;                                    //??INT0?????
  88   1              //    EX0 = 1;                                    //??INT0??
  89   1              //    EA = 1;
  90   1              //
  91   1              //      IT1 = 1;                                    //??INT1?????
  92   1              //    EX1 = 1;                                    //??INT1??
  93   1              //    EA = 1;
  94   1      }
  95          
  96          
  97          
  98          #define     RED          0XF800   //红色
  99          #define     GREEN        0X07E0   //绿色
 100          #define     BLUE         0X001F   //蓝色
 101          #define     WHITE        0XFFFF   //白色
 102          
 103          #define DATA_H P2
 104          #define DATA_L P0
 105          
 106          sbit LCD_RESET = P0^3;
 107          sbit LCD_CS = P1^2;
 108          ////sbit LCD_MOSI = P1^4;
 109          ////sbit LCD_MISO = P1^3;
 110          //sbit LCD_SCK = P1^5;//就是TFT上的LCD_RS引脚
 111          
 112          
 113          
 114          
 115          sbit LCD_LED= P1^1;
 116          sbit LCD_CD = P1^0;//就是TFT上的LCD_WR引脚
 117          
C51 COMPILER V9.05   MAIN                                                                  05/06/2023 21:06:01 PAGE 3   

 118          
 119          void Delay1ms()         //@12.000MHz
 120          {
 121   1              unsigned char i, j;
 122   1      
 123   1              i = 12;
 124   1              j = 169;
 125   1              do
 126   1              {
 127   2                      while (--j);
 128   2              } while (--i);
 129   1      }
 130          
 131          void delay_ms(unsigned int ms)
 132          {
 133   1              while(ms--)
 134   1              {
 135   2                      Delay1ms();
 136   2              }
 137   1      }
 138          
 139          void SPI_RW(unsigned char byte)
 140          {
 141   1              SPDAT = byte;                           //??????
 142   1        while (!(SPSTAT & 0x80));               //??????
 143   1        SPSTAT = 0xc0;                          //?????
 144   1              
 145   1      //      for(bit_ctr=0;bit_ctr<8;bit_ctr++) // 输出8位
 146   1      //      {
 147   1      //              LCD_SCK=0;
 148   1      //              LCD_MOSI=(byte&0x80); // MSB TO MOSI
 149   1      //              byte=(byte<<1); // shift next bit to MSB
 150   1      //              LCD_SCK=1;
 151   1      //              byte|=LCD_MISO;         // capture current MISO bit
 152   1      //      }
 153   1      //      return byte;
 154   1              
 155   1      }
 156          
 157          void LCD_CD_DATA(unsigned char val)
 158          {
 159   1              LCD_CS=0;
 160   1              LCD_CD=1;
 161   1              SPI_RW(val);
 162   1              LCD_CS=1;
 163   1      }
 164          
 165          void LCD_CD_REG(unsigned char reg)
 166          {
 167   1              LCD_CS=0;
 168   1              LCD_CD=0;
 169   1              SPI_RW(reg);
 170   1              LCD_CS=1;
 171   1      }
 172          
 173          void LCD_Init()
 174          {
 175   1              LCD_RESET=0;
 176   1              delay_ms(10);
 177   1              LCD_RESET=1;
 178   1              delay_ms(120);
 179   1              LCD_CD_REG(0xCF);  
C51 COMPILER V9.05   MAIN                                                                  05/06/2023 21:06:01 PAGE 4   

 180   1              LCD_CD_DATA(0x00); 
 181   1              LCD_CD_DATA(0xC1); 
 182   1              LCD_CD_DATA(0X30); 
 183   1              LCD_CD_REG(0xED);  
 184   1              LCD_CD_DATA(0x64); 
 185   1              LCD_CD_DATA(0x03); 
 186   1              LCD_CD_DATA(0X12); 
 187   1              LCD_CD_DATA(0X81); 
 188   1              LCD_CD_REG(0xE8);  
 189   1              LCD_CD_DATA(0x85); 
 190   1              LCD_CD_DATA(0x10); 
 191   1              LCD_CD_DATA(0x7A); 
 192   1              LCD_CD_REG(0xCB);  
 193   1              LCD_CD_DATA(0x39); 
 194   1              LCD_CD_DATA(0x2C); 
 195   1              LCD_CD_DATA(0x00); 
 196   1              LCD_CD_DATA(0x34); 
 197   1              LCD_CD_DATA(0x02); 
 198   1              LCD_CD_REG(0xF7);  
 199   1              LCD_CD_DATA(0x20); 
 200   1              LCD_CD_REG(0xEA);  
 201   1              LCD_CD_DATA(0x00); 
 202   1              LCD_CD_DATA(0x00); 
 203   1              LCD_CD_REG(0xC0);    //Power control 
 204   1              LCD_CD_DATA(0x1B);   //VRH[5:0] 
 205   1              LCD_CD_REG(0xC1);    //Power control 
 206   1              LCD_CD_DATA(0x01);   //SAP[2:0];BT[3:0] 
 207   1              LCD_CD_REG(0xC5);    //VCM control 
 208   1              LCD_CD_DATA(0x30);       //3F
 209   1              LCD_CD_DATA(0x30);       //3C
 210   1              LCD_CD_REG(0xC7);    //VCM control2 
 211   1              LCD_CD_DATA(0XB7); 
 212   1              LCD_CD_REG(0x36);    // Memory Access Control 
 213   1              LCD_CD_DATA(0x48); 
 214   1              LCD_CD_REG(0x3A);   
 215   1              LCD_CD_DATA(0x55); 
 216   1              LCD_CD_REG(0xB1);   
 217   1              LCD_CD_DATA(0x00);   
 218   1              LCD_CD_DATA(0x1A); 
 219   1              LCD_CD_REG(0xB6);    // Display Function Control 
 220   1              LCD_CD_DATA(0x0A); 
 221   1              LCD_CD_DATA(0xA2); 
 222   1              LCD_CD_REG(0xF2);    // 3Gamma Function Disable 
 223   1              LCD_CD_DATA(0x00); 
 224   1              LCD_CD_REG(0x26);    //Gamma curve selected 
 225   1              LCD_CD_DATA(0x01); 
 226   1              LCD_CD_REG(0xE0);    //Set Gamma 
 227   1              LCD_CD_DATA(0x0F); 
 228   1              LCD_CD_DATA(0x2A); 
 229   1              LCD_CD_DATA(0x28); 
 230   1              LCD_CD_DATA(0x08); 
 231   1              LCD_CD_DATA(0x0E); 
 232   1              LCD_CD_DATA(0x08); 
 233   1              LCD_CD_DATA(0x54); 
 234   1              LCD_CD_DATA(0XA9); 
 235   1              LCD_CD_DATA(0x43); 
 236   1              LCD_CD_DATA(0x0A); 
 237   1              LCD_CD_DATA(0x0F); 
 238   1              LCD_CD_DATA(0x00); 
 239   1              LCD_CD_DATA(0x00); 
 240   1              LCD_CD_DATA(0x00); 
 241   1              LCD_CD_DATA(0x00);               
C51 COMPILER V9.05   MAIN                                                                  05/06/2023 21:06:01 PAGE 5   

 242   1              LCD_CD_REG(0XE1);    //Set Gamma 
 243   1              LCD_CD_DATA(0x00); 
 244   1              LCD_CD_DATA(0x15); 
 245   1              LCD_CD_DATA(0x17); 
 246   1              LCD_CD_DATA(0x07); 
 247   1              LCD_CD_DATA(0x11); 
 248   1              LCD_CD_DATA(0x06); 
 249   1              LCD_CD_DATA(0x2B); 
 250   1              LCD_CD_DATA(0x56); 
 251   1              LCD_CD_DATA(0x3C); 
 252   1              LCD_CD_DATA(0x05); 
 253   1              LCD_CD_DATA(0x10); 
 254   1              LCD_CD_DATA(0x0F); 
 255   1              LCD_CD_DATA(0x3F); 
 256   1              LCD_CD_DATA(0x3F); 
 257   1              LCD_CD_DATA(0x0F); 
 258   1              LCD_CD_REG(0x2B); 
 259   1              LCD_CD_DATA(0x00);
 260   1              LCD_CD_DATA(0x00);
 261   1              LCD_CD_DATA(0x01);
 262   1              LCD_CD_DATA(0x3f);
 263   1              LCD_CD_REG(0x2A); 
 264   1              LCD_CD_DATA(0x00);
 265   1              LCD_CD_DATA(0x00);
 266   1              LCD_CD_DATA(0x00);
 267   1              LCD_CD_DATA(0xef);       
 268   1              LCD_CD_REG(0x11); //Exit Sleep
 269   1              delay_ms(120);
 270   1              LCD_CD_REG(0x29); //display on  
 271   1      }
 272          typedef uint16_t u16;
*** ERROR C129 IN LINE 272 OF main.c: missing ';' before 'u16'
 273          
 274          
 275          
 276          void LCD_SetArea(unsigned int stx,unsigned int sty,unsigned int endx,unsigned int endy)
 277          {
 278                  LCD_CD_REG(0x2A);  
 279                  LCD_CD_DATA(stx>>8);    
 280                  LCD_CD_DATA(stx&0xff);          
 281                  LCD_CD_DATA(endx>>8); 
 282                  LCD_CD_DATA(endx&0xff); 
 283          
 284                  LCD_CD_REG(0x2B);
 285                  LCD_CD_DATA(sty>>8); 
 286                  LCD_CD_DATA(sty&0xff);  
 287                  LCD_CD_DATA(endy>>8); 
 288                  LCD_CD_DATA(endy&0xff); 
 289          }
 290          
 291          void LcdWirteColorData(unsigned int color)
 292          {
 293                  LCD_CS=0;
 294                  LCD_CD=1;
 295                  SPI_RW(color>>8);
 296                  SPI_RW(color);
 297                  LCD_CS=1;
 298          }
 299          
 300          void LCD_Clear(unsigned int color)
 301          {  
 302                  unsigned int i,j;
C51 COMPILER V9.05   MAIN                                                                  05/06/2023 21:06:01 PAGE 6   

 303          
 304                  LCD_SetArea(0,0,239,319);
 305            LCD_CD_REG(0x2C);
 306                  for(i=0;i<320;i++)
 307                  {
 308                          for(j=0;j<240;j++)
 309                          {
 310                                  LcdWirteColorData(color);
 311                          }
 312                  }
 313          }
 314          sbit X0 = P2 ^ 3;
 315          sbit X1 = P2 ^ 1;
 316          sbit X2 = P3 ^ 7;
 317          sbit X3 = P3 ^ 5;
 318          
 319          
 320          sbit LED0 = P3 ^ 4;
 321          char xin[30]={0};
 322          void shurulvbo(void)
 323          {
 324                  static u8 keybuf[40] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
 325                                                             0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
 326                                                             0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
 327                                                                                                                                                                   0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
 328                                                            }; //矩阵按键扫描缓冲区 8ms
 329                  unsigned char i;
 330                  // i=X0;
 331                  // keybuf[0]=i;
 332                  // i=X1;
 333                  // keybuf[1]=i;
 334                  //  i=X2;
 335                  //  keybuf[2]=i;
 336                  //   i=X3;
 337                  //  keybuf[3]=i;
 338                  i=X0;
 339                  keybuf[0] = (keybuf[0] << 1) | i;
 340                  i=X1;
 341                  keybuf[1] = (keybuf[1] << 1) | i;
 342                  i=X2;
 343                  keybuf[2] = (keybuf[2] << 1) | i;
 344                  i=X3;
 345                  keybuf[3] = (keybuf[3] << 1) | i;
 346                  for (i = 0; i < 10; i++) // 3按键，所以循环3次
 347                  {
 348                          if ((keybuf[i] & 0xFF) == 0x00)
 349                          {
 350                                  xin[i] = 0;
 351                          }
 352                          else if ((keybuf[i] & 0xFF) == 0xFF)
 353                          { // 连续3次扫描值为1，即1*8ms内都是弹起状态时，可认为按键已稳定的弹起
 354                                  xin[i] = 1;
 355                          }
 356                  }
 357          }
 358          void keydown(int i) // 按键按下的处理、、、
 359          {
 360                  printf("keydown %d\r\n", i);
 361                  if(i==0)
 362                  {
 363                          LED0=~LED0;
 364                  }
C51 COMPILER V9.05   MAIN                                                                  05/06/2023 21:06:01 PAGE 7   

 365          }
 366          void keyallchuli()
 367          {
 368                  int i;
 369                  static int flag[10]={0};//标志记录
 370                  for( i=0;i<6;i++)
 371                  {
 372                          if(xin[i]==0)
 373                          {
 374                                  if(flag[i]==0)//代表按键第一次按下。。。
 375                                  {
 376                                          flag[i]=1;
 377                                          keydown(i);
 378                                  }
 379                          }
 380                          else 
 381                                  flag[i]=0;
 382                  }
 383          }
 384          
 385          
 386          void main()
 387          {
 388                    P0M0 = 0x00;
 389              P0M1 = 0x02;
 390              P1M0 = 0x00;
 391              P1M1 = 0x00;
 392              P2M0 = 0x00;
 393              P2M1 = 0x00;
 394              P3M0 = 0x00;
 395              P3M1 = 0x00;
 396              P4M0 = 0x00;
 397              P4M1 = 0x00;
 398              P5M0 = 0x00;
 399              P5M1 = 0x00;
 400                  
 401                   SPCTL = 0x50|0x80;                               //??SPI????
 402              SPSTAT = 0xc0;                              //?????
 403                  LCD_LED=0;
 404                  delay_ms(100);
 405                  
 406          //      SPI_Init();
 407                  LCD_Init();
 408                  UartInit();
 409          
 410                  Timer0Init();
 411                  delay_ms(300);
 412                  // printf("123testruning");
 413                  // printf("xxxx");
 414                  while(1)
 415                  {
 416                          shurulvbo();
 417                          keyallchuli();
 418                          delay_ms(2);
 419                          // LCD_Clear(WHITE);
 420                          // delay_ms(300);
 421                          // LCD_Clear(RED);
 422                          // delay_ms(300);
 423                          // LCD_Clear(BLUE);
 424                          // delay_ms(300);
 425                          // LCD_Clear(GREEN);
 426                          // delay_ms(300);
C51 COMPILER V9.05   MAIN                                                                  05/06/2023 21:06:01 PAGE 8   

 427                          // UartSendStr("123testruning");
 428                  }
 429          }
 430          
 431          
 432          void UartIsr() interrupt 4
 433          {
 434          
 435                  if (RI)
 436                  {
 437                          RI = 0;
 438                  }
 439          }
 440          
 441          void tm0_isr() interrupt 1
 442          {
 443                  
 444          }
 445          
 446          
 447          
 448          
 449          
 450          
 451          
 452          
 453          
 454          
 455          
 456          
 457          
 458          
 459          
 460          
 461          
 462          
 463          
 464          
 465          
 466          

C51 COMPILATION COMPLETE.  0 WARNING(S),  1 ERROR(S)
