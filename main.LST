C51 COMPILER V9.05   MAIN                                                                  05/07/2023 11:25:56 PAGE 1   


C51 COMPILER V9.05, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c LARGE BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include "STC8G.h"
   2          #include <intrins.h>
   3          #include <stdio.h>
   4          #include "lcd.h"
   5          #include <string.h>
   6          #define u8 unsigned char
   7          #define FOSC 11059200UL
   8          #define BRT (65536 - FOSC / 9600 / 4)
   9          
  10          int keyon= 0;
  11          int keylow=1;
  12          int keyok= 2;
  13          int keyup=3;
  14          
  15          int nowzhi=1000;
  16          int setzhi=500;
  17          #define maxsetzhi 1000 
  18          
  19          
  20          
  21          bit busy;
  22          void UartInit() // 11.0592 9600
  23          {
  24   1              SCON = 0x50;  // 8位数据,可变波特率
  25   1              AUXR |= 0x40; // 定时器时钟1T模式
  26   1              AUXR &= 0xFE; // 串口1选择定时器1为波特率发生器
  27   1              TMOD &= 0x0F; // 设置定时器模式
  28   1              TL1 = 0xE0;       // 设置定时初始值
  29   1              TH1 = 0xFE;       // 设置定时初始值
  30   1              ET1 = 0;          // 禁止定时器%d中断
  31   1              TR1 = 1;          // 定时器1开始计时
  32   1              ES = 1;
  33   1              EA = 1;
  34   1              P_SW1 = 0x00; // RXD/P3.0, TXD/P3.1
  35   1              //  P_SW1 = 0x40;                               //RXD_2/P3.6, TXD_2/P3.7
  36   1              //  P_SW1 = 0x80;                               //RXD_3/P1.6, TXD_3/P1.7
  37   1              //      PS=1;
  38   1      }
  39          void UartSendByte(u8 dat)
  40          {
  41   1              SBUF = dat;
  42   1              while (TI == 0)
  43   1                      ;
  44   1              TI = 0;
  45   1      }
  46          char putchar (char dat)
  47          {
  48   1              SBUF = dat;
  49   1              while (TI == 0)
  50   1                      ;
  51   1              TI = 0;
  52   1              return (dat);
  53   1      }
  54          
  55          void UartSendStr(u8 *str)
C51 COMPILER V9.05   MAIN                                                                  05/07/2023 11:25:56 PAGE 2   

  56          {
  57   1              while (*str)
  58   1              {
  59   2                      UartSendByte(*str);
  60   2                      str++;
  61   2              }
  62   1      }
  63          void Uart2Init()
  64          {
  65   1              S2CON = 0x10;
  66   1              T2L = BRT;
  67   1              T2H = BRT >> 8;
  68   1              AUXR |= 0x14;
  69   1              IE2 = 0x01;
  70   1              EA = 1;
  71   1      }
  72          void Uart2Send(char dat)
  73          {
  74   1              while (busy)
  75   1                      ;
  76   1              busy = 1;
  77   1              S2BUF = dat;
  78   1      }
  79          
  80          void Uart2SendStr(char *p)
  81          {
  82   1              while (*p)
  83   1              {
  84   2                      Uart2Send(*p++);
  85   2              }
  86   1      }
  87          
  88          
  89          void Timer0Init(void) // 2毫秒@11.0592MHz
  90          {
  91   1              AUXR |= 0x80; // 定时器时钟1T模式
  92   1              TMOD &= 0xF0; // 设置定时器模式
  93   1              TL0 = 0x9a;       // 设置定时初值
  94   1              TH0 = 0xa9;       // 设置定时初值
  95   1              TF0 = 0;          // 清除TF0标志
  96   1              TR0 = 1;          // 定时器0开始计时
  97   1              TR0 = 1;          // 定时器0开始计时
  98   1              ET0 = 1;          // 使能定时器0中断
  99   1              PT0 = 1;
 100   1              EA = 1;
 101   1              //    IT0 = 1;                                    //??INT0?????
 102   1              //    EX0 = 1;                                    //??INT0??
 103   1              //    EA = 1;
 104   1              //
 105   1              //      IT1 = 1;                                    //??INT1?????
 106   1              //    EX1 = 1;                                    //??INT1??
 107   1              //    EA = 1;
 108   1      }
 109          
 110          
 111          
 112          
 113          
 114          
 115          
 116          sbit X0 = P2 ^ 3;
 117          sbit X1 = P2 ^ 1;
C51 COMPILER V9.05   MAIN                                                                  05/07/2023 11:25:56 PAGE 3   

 118          sbit X2 = P3 ^ 7;
 119          sbit X3 = P3 ^ 5;
 120          
 121          
 122          
 123          sbit LED0 = P3 ^ 4;
 124          char xin[30]={0};
 125          void shurulvbo(void)
 126          {
 127   1              static u8 keybuf[40] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
 128   1                                                         0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
 129   1                                                         0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
 130   1                                                                                                                                                               0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
 131   1                                                        }; //矩阵按键扫描缓冲区 8ms
 132   1              unsigned char i;
 133   1              // i=X0;
 134   1              // keybuf[0]=i;
 135   1              // i=X1;
 136   1              // keybuf[1]=i;
 137   1              //  i=X2;
 138   1              //  keybuf[2]=i;
 139   1              //   i=X3;
 140   1              //  keybuf[3]=i;
 141   1              i=X0;
 142   1              keybuf[0] = (keybuf[0] << 1) | i;
 143   1              i=X1;
 144   1              keybuf[1] = (keybuf[1] << 1) | i;
 145   1              i=X2;
 146   1              keybuf[2] = (keybuf[2] << 1) | i;
 147   1              i=X3;
 148   1              keybuf[3] = (keybuf[3] << 1) | i;
 149   1              for (i = 0; i < 10; i++) // 3按键，所以循环3次
 150   1              {
 151   2                      if ((keybuf[i] & 0xFF) == 0x00)
 152   2                      {
 153   3                              xin[i] = 0;
 154   3                      }
 155   2                      else if ((keybuf[i] & 0xFF) == 0xFF)
 156   2                      { // 连续3次扫描值为1，即1*8ms内都是弹起状态时，可认为按键已稳定的弹起
 157   3                              xin[i] = 1;
 158   3                      }
 159   2              }
 160   1      }
 161          void setzhichange(int a)
 162          {
 163   1              if(setzhi+a<0)
 164   1              {
 165   2                      return ;
 166   2              }
 167   1              if(setzhi+a>maxsetzhi)
 168   1              {
 169   2                      return; 
 170   2              }
 171   1              setzhi=setzhi+a;
 172   1      }
 173          
 174          void keydown(int i) // 按键按下的处理、、、
 175          {
 176   1              printf("keydown %d\r\n", i);
 177   1              if(i==0)
 178   1              {
 179   2                      LED0=~LED0;
C51 COMPILER V9.05   MAIN                                                                  05/07/2023 11:25:56 PAGE 4   

 180   2              }
 181   1              if(i==keylow)
 182   1              {
 183   2                      setzhichange(-1);
 184   2                      return;
 185   2              }
 186   1              if(i==keyup)
 187   1              {
 188   2                      setzhichange(1);
 189   2                      return;
 190   2              }
 191   1              if(i==keyok)
 192   1              {
 193   2                      nowzhi=setzhi;
 194   2                      printf("setdianliu%d\r\n",nowzhi);
 195   2              }
 196   1      }
 197          // 按键连续按下多少次的操作。。
 198          int setbizhi(int times)
 199          {
 200   1              if(times<100)
 201   1              {
 202   2                      return 1;
 203   2              }
 204   1              if(times<1000)
 205   1              {
 206   2                      return 10;
 207   2              }
 208   1              return 50  ;
 209   1      }
 210          // 2ms 一次的话，那300ms一次ok的吧。。
 211          void dolongtimes(int i,int times)
 212          {
 213   1              int xielv;
 214   1              times=times-300;
 215   1              if(times<0)
 216   1              {
 217   2                      return ;
 218   2              }
 219   1              xielv=setbizhi(times);
 220   1              if(times%150!=0)
 221   1              {
 222   2                      return;
 223   2              }
 224   1              printf("dolongtimes %d xielv %d\r\n", i,xielv);
 225   1              if(i==keylow)
 226   1              {
 227   2                      setzhichange(-xielv);
 228   2                      return;
 229   2              }
 230   1              if(i==keyup)
 231   1              {
 232   2                      setzhichange(xielv);
 233   2                      return;
 234   2              }
 235   1      }
 236          void keyallchuli()
 237          {
 238   1              int i;
 239   1              static char flag[10]={0};//标志记录
 240   1              static int dowmtimes[10]={0};//标志记录
 241   1              for( i=0;i<6;i++)
C51 COMPILER V9.05   MAIN                                                                  05/07/2023 11:25:56 PAGE 5   

 242   1              {
 243   2                      if(xin[i]==0)
 244   2                      {
 245   3                              if(flag[i]==0)//代表按键第一次按下。。。
 246   3                              {
 247   4                                      flag[i]=1;
 248   4                                      keydown(i);
 249   4                              }
 250   3                              dowmtimes[i]++;
 251   3                              dolongtimes(i,dowmtimes[i]);
 252   3                      }
 253   2                      else 
 254   2                      {
 255   3                              flag[i]=0;
 256   3                              dowmtimes[i]=0;
 257   3                      }
 258   2              }
 259   1      }
 260          
 261          
 262          
 263          
 264          void shownow()
 265          {
 266   1              char dataxx[40];
 267   1              sprintf(dataxx,"NOW:%05d",nowzhi);
 268   1              LCD_ShowString(0,40,dataxx,RED,WHITE,32,0);
 269   1      }
 270          void showsetzhi()
 271          {
 272   1              char dataxx[40];
 273   1              sprintf(dataxx,"SET:%05d",setzhi);
 274   1              LCD_ShowString(0,80,dataxx,RED,WHITE,32,0);
 275   1      }
 276          void showdata()
 277          {
 278   1              shownow();
 279   1              showsetzhi();
 280   1      }
 281          
 282          void main()
 283          {
 284   1              int i=0;
 285   1              P0M0 = 0x00;
 286   1          P0M1 = 0x02;
 287   1          P1M0 = 0x00;
 288   1          P1M1 = 0x00;
 289   1          P2M0 = 0x00;
 290   1          P2M1 = 0x00;
 291   1          P3M0 = 0x00;
 292   1          P3M1 = 0x00;
 293   1          P4M0 = 0x00;
 294   1          P4M1 = 0x00;
 295   1          P5M0 = 0x00;
 296   1          P5M1 = 0x00;
 297   1              
 298   1               SPCTL = 0x50|0x80;                               //??SPI????
 299   1          SPSTAT = 0xc0;                              //?????
 300   1              LCD_LED=0;
 301   1              delay_ms(100);
 302   1              
 303   1              LCD_Init();
C51 COMPILER V9.05   MAIN                                                                  05/07/2023 11:25:56 PAGE 6   

 304   1              UartInit();
 305   1      
 306   1              Timer0Init();
 307   1              delay_ms(100);
 308   1      
 309   1      
 310   1              LCD_Fill(0,0,320,240,WHITE);
 311   1              delay_ms(100);
 312   1              while(1)
 313   1              {
 314   2                      shurulvbo();
 315   2                  keyallchuli();
 316   2             
 317   2                      // printf("123testruning");
 318   2                      // printf("xxxx");
 319   2                      delay_ms(1);
 320   2                      if(i++>100)
 321   2                      {
 322   3                              i=0;
 323   3                              showdata();
 324   3                      }
 325   2              
 326   2                      
 327   2              }
 328   1      }
 329          
 330          
 331          void UartIsr() interrupt 4
 332          {
 333   1      
 334   1              if (RI)
 335   1              {
 336   2                      RI = 0;
 337   2              }
 338   1      }
 339          
 340          void tm0_isr() interrupt 1
 341          {
 342   1              
 343   1      }
 344          
 345          
 346          
 347          
 348          
 349          
 350          
 351          
 352          
 353          
 354          
 355          
 356          
 357          
 358          
 359          
 360          
 361          
 362          
 363          
 364          
 365          
C51 COMPILER V9.05   MAIN                                                                  05/07/2023 11:25:56 PAGE 7   



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1137    ----
   CONSTANT SIZE    =     72    ----
   XDATA SIZE       =    112      93
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
