C51 COMPILER V9.05   MAIN                                                                  05/07/2023 00:36:04 PAGE 1   


C51 COMPILER V9.05, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c LARGE BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include "STC8G.h"
   2          #include <intrins.h>
   3          #include <stdio.h>
   4          #include "lcd.h"
   5          #include <string.h>
   6          #define u8 unsigned char
   7          #define FOSC 11059200UL
   8          #define BRT (65536 - FOSC / 9600 / 4)
   9          bit busy;
  10          void UartInit() // 11.0592 9600
  11          {
  12   1              SCON = 0x50;  // 8位数据,可变波特率
  13   1              AUXR |= 0x40; // 定时器时钟1T模式
  14   1              AUXR &= 0xFE; // 串口1选择定时器1为波特率发生器
  15   1              TMOD &= 0x0F; // 设置定时器模式
  16   1              TL1 = 0xE0;       // 设置定时初始值
  17   1              TH1 = 0xFE;       // 设置定时初始值
  18   1              ET1 = 0;          // 禁止定时器%d中断
  19   1              TR1 = 1;          // 定时器1开始计时
  20   1              ES = 1;
  21   1              EA = 1;
  22   1              P_SW1 = 0x00; // RXD/P3.0, TXD/P3.1
  23   1              //  P_SW1 = 0x40;                               //RXD_2/P3.6, TXD_2/P3.7
  24   1              //  P_SW1 = 0x80;                               //RXD_3/P1.6, TXD_3/P1.7
  25   1              //      PS=1;
  26   1      }
  27          void UartSendByte(u8 dat)
  28          {
  29   1              SBUF = dat;
  30   1              while (TI == 0)
  31   1                      ;
  32   1              TI = 0;
  33   1      }
  34          char putchar (char dat)
  35          {
  36   1              SBUF = dat;
  37   1              while (TI == 0)
  38   1                      ;
  39   1              TI = 0;
  40   1              return (SBUF = dat);
  41   1      }
  42          
  43          void UartSendStr(u8 *str)
  44          {
  45   1              while (*str)
  46   1              {
  47   2                      UartSendByte(*str);
  48   2                      str++;
  49   2              }
  50   1      }
  51          void Uart2Init()
  52          {
  53   1              S2CON = 0x10;
  54   1              T2L = BRT;
  55   1              T2H = BRT >> 8;
C51 COMPILER V9.05   MAIN                                                                  05/07/2023 00:36:04 PAGE 2   

  56   1              AUXR |= 0x14;
  57   1              IE2 = 0x01;
  58   1              EA = 1;
  59   1      }
  60          void Uart2Send(char dat)
  61          {
  62   1              while (busy)
  63   1                      ;
  64   1              busy = 1;
  65   1              S2BUF = dat;
  66   1      }
  67          
  68          void Uart2SendStr(char *p)
  69          {
  70   1              while (*p)
  71   1              {
  72   2                      Uart2Send(*p++);
  73   2              }
  74   1      }
  75          
  76          
  77          void Timer0Init(void) // 2毫秒@11.0592MHz
  78          {
  79   1              AUXR |= 0x80; // 定时器时钟1T模式
  80   1              TMOD &= 0xF0; // 设置定时器模式
  81   1              TL0 = 0x9a;       // 设置定时初值
  82   1              TH0 = 0xa9;       // 设置定时初值
  83   1              TF0 = 0;          // 清除TF0标志
  84   1              TR0 = 1;          // 定时器0开始计时
  85   1              TR0 = 1;          // 定时器0开始计时
  86   1              ET0 = 1;          // 使能定时器0中断
  87   1              PT0 = 1;
  88   1              EA = 1;
  89   1              //    IT0 = 1;                                    //??INT0?????
  90   1              //    EX0 = 1;                                    //??INT0??
  91   1              //    EA = 1;
  92   1              //
  93   1              //      IT1 = 1;                                    //??INT1?????
  94   1              //    EX1 = 1;                                    //??INT1??
  95   1              //    EA = 1;
  96   1      }
  97          
  98          
  99          
 100          
 101          
 102          
 103          
 104          sbit X0 = P2 ^ 3;
 105          sbit X1 = P2 ^ 1;
 106          sbit X2 = P3 ^ 7;
 107          sbit X3 = P3 ^ 5;
 108          
 109          
 110          sbit LED0 = P3 ^ 4;
 111          char xin[30]={0};
 112          void shurulvbo(void)
 113          {
 114   1              static u8 keybuf[40] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
 115   1                                                         0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
 116   1                                                         0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
 117   1                                                                                                                                                               0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
C51 COMPILER V9.05   MAIN                                                                  05/07/2023 00:36:04 PAGE 3   

 118   1                                                        }; //矩阵按键扫描缓冲区 8ms
 119   1              unsigned char i;
 120   1              // i=X0;
 121   1              // keybuf[0]=i;
 122   1              // i=X1;
 123   1              // keybuf[1]=i;
 124   1              //  i=X2;
 125   1              //  keybuf[2]=i;
 126   1              //   i=X3;
 127   1              //  keybuf[3]=i;
 128   1              i=X0;
 129   1              keybuf[0] = (keybuf[0] << 1) | i;
 130   1              i=X1;
 131   1              keybuf[1] = (keybuf[1] << 1) | i;
 132   1              i=X2;
 133   1              keybuf[2] = (keybuf[2] << 1) | i;
 134   1              i=X3;
 135   1              keybuf[3] = (keybuf[3] << 1) | i;
 136   1              for (i = 0; i < 10; i++) // 3按键，所以循环3次
 137   1              {
 138   2                      if ((keybuf[i] & 0xFF) == 0x00)
 139   2                      {
 140   3                              xin[i] = 0;
 141   3                      }
 142   2                      else if ((keybuf[i] & 0xFF) == 0xFF)
 143   2                      { // 连续3次扫描值为1，即1*8ms内都是弹起状态时，可认为按键已稳定的弹起
 144   3                              xin[i] = 1;
 145   3                      }
 146   2              }
 147   1      }
 148          void keydown(int i) // 按键按下的处理、、、
 149          {
 150   1              printf("keydown %d\r\n", i);
 151   1              if(i==0)
 152   1              {
 153   2                      LED0=~LED0;
 154   2              }
 155   1      }
 156          void keyallchuli()
 157          {
 158   1              int i;
 159   1              static int flag[10]={0};//标志记录
 160   1              for( i=0;i<6;i++)
 161   1              {
 162   2                      if(xin[i]==0)
 163   2                      {
 164   3                              if(flag[i]==0)//代表按键第一次按下。。。
 165   3                              {
 166   4                                      flag[i]=1;
 167   4                                      keydown(i);
 168   4                              }
 169   3                      }
 170   2                      else 
 171   2                              flag[i]=0;
 172   2              }
 173   1      }
 174          
 175          
 176          int times=1;
 177          void showdata()
 178          {
 179   1              int i;
C51 COMPILER V9.05   MAIN                                                                  05/07/2023 00:36:04 PAGE 4   

 180   1              char dataxx[40];
 181   1              times=times+1;
 182   1              sprintf(dataxx,"LCD_W:%d",times);
 183   1              LCD_ShowString(0,40,dataxx,RED,WHITE,32,0);
 184   1      }
*** WARNING C280 IN LINE 179 OF main.c: 'i': unreferenced local variable
 185          void main()
 186          {
 187   1                P0M0 = 0x00;
 188   1          P0M1 = 0x02;
 189   1          P1M0 = 0x00;
 190   1          P1M1 = 0x00;
 191   1          P2M0 = 0x00;
 192   1          P2M1 = 0x00;
 193   1          P3M0 = 0x00;
 194   1          P3M1 = 0x00;
 195   1          P4M0 = 0x00;
 196   1          P4M1 = 0x00;
 197   1          P5M0 = 0x00;
 198   1          P5M1 = 0x00;
 199   1              
 200   1               SPCTL = 0x50|0x80;                               //??SPI????
 201   1          SPSTAT = 0xc0;                              //?????
 202   1              LCD_LED=0;
 203   1              delay_ms(100);
 204   1              
 205   1      //      SPI_Init();
 206   1              LCD_Init();
 207   1              // UartInit();
 208   1      
 209   1              // Timer0Init();
 210   1              delay_ms(100);
 211   1              // printf("123testruning");
 212   1              // printf("xxxx");
 213   1      
 214   1              LCD_Fill(0,0,320,240,WHITE);
 215   1              delay_ms(100);
 216   1              while(1)
 217   1              {
 218   2              showdata();
 219   2                      // LCD_ShowChinese(0,0,"中景园电子",RED,WHITE,32,0);
 220   2                      // LCD_ShowString(0,40,"LCD_W:",RED,WHITE,32,0);
 221   2                      // LCD_ShowIntNum(48,40,LCD_W,3,RED,WHITE,16);
 222   2                      // LCD_ShowString(80,40,"LCD_H:",RED,WHITE,16,0);
 223   2                      // LCD_ShowIntNum(128,40,LCD_H,3,RED,WHITE,16);
 224   2                      // LCD_ShowString(80,40,"LCD_H:",RED,WHITE,32,0);
 225   2                      // LCD_ShowString(0,70,"Increaseing Nun:",RED,WHITE,16,0);
 226   2                      delay_ms(300);
 227   2                      // LCD_ShowString(0,40,"LCD_W:",RED,WHITE,16,0);
 228   2                      // shurulvbo();
 229   2                      // keyallchuli();
 230   2                      // delay_ms(2);
 231   2                      // LCD_Clear(WHITE);
 232   2                      // delay_ms(300);
 233   2                      // LCD_Clear(RED);
 234   2                      // delay_ms(300);
 235   2                      // LCD_Clear(BLUE);
 236   2                      // delay_ms(300);
 237   2                      // LCD_Clear(GREEN);
 238   2                      // delay_ms(300);
 239   2                      // UartSendStr("123testruning");
 240   2              }
C51 COMPILER V9.05   MAIN                                                                  05/07/2023 00:36:04 PAGE 5   

 241   1      }
 242          
 243          
 244          void UartIsr() interrupt 4
 245          {
 246   1      
 247   1              if (RI)
 248   1              {
 249   2                      RI = 0;
 250   2              }
 251   1      }
 252          
 253          void tm0_isr() interrupt 1
 254          {
 255   1              
 256   1      }
 257          
 258          
 259          
 260          
 261          
 262          
 263          
 264          
 265          
 266          
 267          
 268          
 269          
 270          
 271          
 272          
 273          
 274          
 275          
 276          
 277          
 278          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    634    ----
   CONSTANT SIZE    =     22    ----
   XDATA SIZE       =     92      49
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
