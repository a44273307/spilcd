C51 COMPILER V9.05   MAIN                                                                  05/09/2023 21:06:00 PAGE 1   


C51 COMPILER V9.05, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c LARGE BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include "STC8G.h"
   2          #include <intrins.h>
   3          #include <stdio.h>
   4          #include "lcd.h"
   5          #include <string.h>
   6          
   7          #include <stdio.h>
   8          #include <string.h>
   9          #include <stdlib.h>
  10          #include "pic.h"
  11          
  12          #define u8 unsigned char
  13          #define FOSC 24000000UL
  14          #define BRT (65536 - FOSC / 9600 / 4)
  15          
  16          int keyon= 0;
  17          int keylow=1;
  18          int keyok= 2;
  19          int keyup=3;
  20          
  21          int nowzhi=2047;
  22          int setzhi=2047;
  23          #define maxsetzhi 2047 
  24          
  25          
  26          
  27          bit busy;
  28          void UartInit() // 11.0592 9600
  29          {
  30   1              SCON = 0x50;            //8位数据,可变波特率
  31   1              AUXR |= 0x40;           //定时器时钟1T模式
  32   1              AUXR &= 0xFE;           //串口1选择定时器1为波特率发生器
  33   1              TMOD &= 0x0F;           //设置定时器模式
  34   1              TL1 = 0x8F;             //设置定时初始值
  35   1              TH1 = 0xFD;             //设置定时初始值
  36   1              ET1 = 0;                //禁止定时器%d中断
  37   1              TR1 = 1;                //定时器1开始计时
  38   1              ES = 1;
  39   1              EA = 1;
  40   1              P_SW1 = 0x00; // RXD/P3.0, TXD/P3.1
  41   1      }
  42          void UartSendByte(u8 dat)
  43          {
  44   1              SBUF = dat;
  45   1              while (TI == 0)
  46   1                      ;
  47   1              TI = 0;
  48   1      }
  49          char putchar (char dat)
  50          {
  51   1              SBUF = dat;
  52   1              while (TI == 0)
  53   1                      ;
  54   1              TI = 0;
  55   1              return (dat);
C51 COMPILER V9.05   MAIN                                                                  05/09/2023 21:06:00 PAGE 2   

  56   1      }
  57          
  58          void UartSendStr(u8 *str)
  59          {
  60   1              while (*str)
  61   1              {
  62   2                      UartSendByte(*str);
  63   2                      str++;
  64   2              }
  65   1      }
  66          void Uart2Init()
  67          {
  68   1              S2CON = 0x10;
  69   1              T2L = BRT;
  70   1              T2H = BRT >> 8;
  71   1              AUXR |= 0x14;
  72   1              IE2 = 0x01;
  73   1              EA = 1;
  74   1      }
  75          void Uart2Send(char dat)
  76          {
  77   1              while (busy)
  78   1                      ;
  79   1              busy = 1;
  80   1              S2BUF = dat;
  81   1      }
  82          
  83          void Uart2SendStr(char *p)
  84          {
  85   1              while (*p)
  86   1              {
  87   2                      Uart2Send(*p++);
  88   2              }
  89   1      }
  90          
  91          
  92          void Timer0Init(void) // 2毫秒@11.0592MHz
  93          {
  94   1              AUXR |= 0x80;           //定时器时钟1T模式
  95   1              TMOD &= 0xF0;           //设置定时器模式
  96   1              TL0 = 0x80;             //设置定时初始值
  97   1              TH0 = 0x44;             //设置定时初始值
  98   1              TF0 = 0;                //清除TF0标志
  99   1              TR0 = 1;                //定时器0开始计时
 100   1              TR0 = 1;          // 定时器0开始计时
 101   1              ET0 = 1;          // 使能定时器0中断
 102   1              PT0 = 1;
 103   1              EA = 1;
 104   1              //    IT0 = 1;                                    //??INT0?????
 105   1              //    EX0 = 1;                                    //??INT0??
 106   1              //    EA = 1;
 107   1              //
 108   1              //      IT1 = 1;                                    //??INT1?????
 109   1              //    EX1 = 1;                                    //??INT1??
 110   1              //    EA = 1;
 111   1      }
 112          
 113          
 114          
 115          
 116          
 117          
C51 COMPILER V9.05   MAIN                                                                  05/09/2023 21:06:00 PAGE 3   

 118          
 119          sbit X0 = P2 ^ 3;
 120          sbit X1 = P2 ^ 1;
 121          sbit X2 = P3 ^ 7;
 122          sbit X3 = P3 ^ 5;
 123          
 124          
 125          
 126          sbit LED3 = P3 ^ 4;
 127          sbit LED2 = P3 ^ 6;
 128          
 129          sbit LED1 = P2 ^ 0;
 130          sbit LED0 = P2 ^ 2;
 131          sbit Y3 = P3 ^ 4;
 132          sbit Y2 = P3 ^ 6;
 133          
 134          sbit Y1 = P2 ^ 0;
 135          sbit Y0 = P2 ^ 2;
 136          
 137          
 138          
 139          char xin[30]={0};
 140          void shurulvbo(void)
 141          {
 142   1              static u8 keybuf[40] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
 143   1                                                         0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
 144   1                                                         0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
 145   1                                                                                                                                                               0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
 146   1                                                        }; //矩阵按键扫描缓冲区 8ms
 147   1              unsigned char i;
 148   1              // i=X0;
 149   1              // keybuf[0]=i;
 150   1              // i=X1;
 151   1              // keybuf[1]=i;
 152   1              //  i=X2;
 153   1              //  keybuf[2]=i;
 154   1              //   i=X3;
 155   1              //  keybuf[3]=i;
 156   1              i=X0;
 157   1              keybuf[0] = (keybuf[0] << 1) | i;
 158   1              i=X1;
 159   1              keybuf[1] = (keybuf[1] << 1) | i;
 160   1              i=X2;
 161   1              keybuf[2] = (keybuf[2] << 1) | i;
 162   1              i=X3;
 163   1              keybuf[3] = (keybuf[3] << 1) | i;
 164   1              for (i = 0; i < 10; i++) // 3按键，所以循环3次
 165   1              {
 166   2                      if ((keybuf[i] & 0xFF) == 0x00)
 167   2                      {
 168   3                              xin[i] = 0;
 169   3                      }
 170   2                      else if ((keybuf[i] & 0xFF) == 0xFF)
 171   2                      { // 连续3次扫描值为1，即1*8ms内都是弹起状态时，可认为按键已稳定的弹起
 172   3                              xin[i] = 1;
 173   3                      }
 174   2              }
 175   1      }
 176          char flagsetzhichange=0;
 177          void setzhichange(int a)
 178          {
 179   1              if(setzhi+a<0)
C51 COMPILER V9.05   MAIN                                                                  05/09/2023 21:06:00 PAGE 4   

 180   1              {
 181   2                      setzhi=0;
 182   2                      // 0的情况也发，保证能够被收到。。
 183   2                      flagsetzhichange=1;
 184   2                      printf("setdianliu%d\r\n",setzhi);
 185   2                      return ;
 186   2              }
 187   1              if(setzhi+a>maxsetzhi)
 188   1              {
 189   2                      setzhi=maxsetzhi;
 190   2                      return; 
 191   2              }
 192   1              setzhi=setzhi+a;
 193   1              flagsetzhichange=1;
 194   1              printf("setdianliu%d\r\n",setzhi);
 195   1              // printf("setzhi %d",setzhi);
 196   1      }
 197          
 198          void keydown(int i) // 按键按下的处理、、、
 199          {
 200   1              
 201   1              if(i==0)
 202   1              {
 203   2                      LED0=~LED0;
 204   2              }
 205   1              if(i==keylow)
 206   1              {
 207   2                      setzhichange(-1);
 208   2                      return;
 209   2              }
 210   1              if(i==keyup)
 211   1              {
 212   2                      setzhichange(1);
 213   2                      return;
 214   2              }
 215   1              if(i==keyok)
 216   1              {
 217   2                      nowzhi=setzhi;
 218   2                      // printf("setdianliu%d\r\n",nowzhi);
 219   2              }
 220   1      }
 221          int keyshi=5;
 222          // 按键连续按下多少次的操作。。
 223          int setbizhi(int times)
 224          {
 225   1              if(times<15*keyshi)
 226   1              {
 227   2                      return 1;
 228   2              }
 229   1              if(times<30*keyshi)
 230   1              {
 231   2                      return 10;
 232   2              }
 233   1              return 50  ;
 234   1      }
 235          // 2ms 一次的话，那300ms一次ok的吧。。
 236          void dolongtimes(int i,int times)
 237          {
 238   1              int xielv;
 239   1              times=times-150;
 240   1              if(times<0)
 241   1              {
C51 COMPILER V9.05   MAIN                                                                  05/09/2023 21:06:00 PAGE 5   

 242   2                      return ;
 243   2              }
 244   1              xielv=setbizhi(times);
 245   1              if(times%keyshi!=0)
 246   1              {
 247   2                      return;
 248   2              }
 249   1              if(i==keylow)
 250   1              {
 251   2                      setzhichange(-xielv);
 252   2                      return;
 253   2              }
 254   1              if(i==keyup)
 255   1              {
 256   2                      setzhichange(xielv);
 257   2                      return;
 258   2              }
 259   1      }
 260          void yout_set(char weizhi,char zhi)
 261          {
 262   1      if(weizhi==0)Y0=zhi;
 263   1      if(weizhi==1)Y1=zhi;
 264   1      if(weizhi==2)Y2=zhi;
 265   1      if(weizhi==3)Y3=zhi;
 266   1      
 267   1      }
 268          void ledclose(int weizhi)
 269          {
 270   1              if(weizhi==keyon)
 271   1              {
 272   2                      return ;
 273   2              }
 274   1              yout_set(weizhi,1);
 275   1      }
 276          void ledopen(int weizhi)
 277          {
 278   1              if(weizhi==keyon)
 279   1              {
 280   2                      return ;
 281   2              }
 282   1              yout_set(weizhi,0);
 283   1      }
 284          void keyallchuli()
 285          {
 286   1              int i;
 287   1              static char flag[10]={0};//标志记录
 288   1              static int dowmtimes[10]={0};//标志记录
 289   1              for( i=0;i<6;i++)
 290   1              {
 291   2                      if(xin[i]==0)
 292   2                      {
 293   3                              if(flag[i]==0)//代表按键第一次按下。。。
 294   3                              {
 295   4                                      flag[i]=1;
 296   4                                      keydown(i);
 297   4                              }
 298   3                              ledopen(i);
 299   3                              dowmtimes[i]++;
 300   3                              dolongtimes(i,dowmtimes[i]);
 301   3                      }
 302   2                      else 
 303   2                      {
C51 COMPILER V9.05   MAIN                                                                  05/09/2023 21:06:00 PAGE 6   

 304   3                              flag[i]=0;
 305   3                              dowmtimes[i]=0;
 306   3                              ledclose(i);
 307   3                      }
 308   2              }
 309   1      }
 310          
 311          int tmp=203;// 温度值
 312          void shownwendu()
 313          {
 314   1              char dataxx[40];
 315   1              sprintf(dataxx,"TMP:%3d.%01d  ",tmp/10,tmp%10);
 316   1              LCD_ShowString(0,80,dataxx,RED,WHITE,32,0);
 317   1      }
 318          
 319          void shownow()
 320          {
 321   1              // char dataxx[40];
 322   1              // sprintf(dataxx,"NOW:%05d",nowzhi);
 323   1              // LCD_ShowString(0,40,dataxx,RED,WHITE,32,0);
 324   1      }
 325          
 326          #define maxjindu 16
 327          #define qidian 0
 328          void pingmuclear()
 329          {
 330   1              char dataxx[60]={0};
 331   1              static int runflag2=0;
 332   1              int i;
 333   1              if(runflag2==1)
 334   1              {
 335   2                      return ;
 336   2              }
 337   1              runflag2=1;
 338   1              LCD_Clear(WHITE);
 339   1      
 340   1              
 341   1              sprintf(dataxx,"                     ",1);
 342   1              for( i=0;i<10;i++)
 343   1              {
 344   2                      LCD_ShowString(0,i*30,dataxx,RED,WHITE,32,0);
 345   2                      delay_ms(10);
 346   2              }
 347   1              LCD_ShowString(0,0,"Circle TAC",RED,WHITE,32,0);
 348   1      
 349   1      }
 350          void showhenxiang()
 351          {
 352   1              int i;
 353   1              char dataxx[60]={0};
 354   1              int jindu;
 355   1              static int runflag=0;
 356   1              if(runflag==1)
 357   1              {
 358   2                      return ;
 359   2              }
 360   1              runflag=1;
 361   1              
 362   1              for(i=0;i<maxjindu;i++)
 363   1              {
 364   2                      dataxx[i]='-';
 365   2              }
C51 COMPILER V9.05   MAIN                                                                  05/09/2023 21:06:00 PAGE 7   

 366   1              pingmuclear();
 367   1              LCD_ShowString(qidian,140,dataxx,RED,WHITE,32,0);
 368   1              LCD_ShowString(qidian,140+40,dataxx,RED,WHITE,32,0);
 369   1              LCD_ShowString(qidian,140+40+30,"0            12bit          2047",RED,WHITE,16,0);
 370   1      }
*** WARNING C280 IN LINE 354 OF main.c: 'jindu': unreferenced local variable
 371          
 372          void showjindtiao()
 373          {
 374   1              int i;
 375   1              char dataxx[60]={0};
 376   1              int jindu;
 377   1              jindu=setzhi*maxjindu/maxsetzhi;
 378   1              for(i=0;i<maxjindu;i++)
 379   1              {
 380   2                      if(i<jindu)
 381   2                      dataxx[i]='<';
 382   2                      else
 383   2                      dataxx[i]=' ';
 384   2                      
 385   2              }
 386   1              showhenxiang();
 387   1              LCD_ShowString(qidian,160,dataxx,RED,WHITE,32,0);
 388   1      }
 389          void showsetzhi()
 390          {
 391   1              char dataxx[40];
 392   1              sprintf(dataxx,"SET:        %04d    ",setzhi);
 393   1              LCD_ShowString(0,120,dataxx,RED,WHITE,32,0);
 394   1              showjindtiao();
 395   1      
 396   1      }
 397          void showdata()
 398          {
 399   1              shownow();
 400   1              showsetzhi();
 401   1              shownwendu();
 402   1      }
 403          void getwendu();
 404          
 405          void main()
 406          {
 407   1              
 408   1              int rumtimes=0;
 409   1              delay_ms(100);
 410   1              P0M0 = 0x00;
 411   1          P0M1 = 0x02;
 412   1          P1M0 = 0x00;
 413   1          P1M1 = 0x00;
 414   1          P2M0 = 0x00;
 415   1          P2M1 = 0x00;
 416   1          P3M0 = 0x00;
 417   1          P3M1 = 0x00;
 418   1          P4M0 = 0x00;
 419   1          P4M1 = 0x00;
 420   1          P5M0 = 0x00;
 421   1          P5M1 = 0x00;
 422   1              
 423   1              SPCTL = 0x50|0x80;                               //??SPI????
 424   1          SPSTAT = 0xc0;                              //?????
 425   1              LCD_LED=0;
 426   1              LED0=~LED0;
C51 COMPILER V9.05   MAIN                                                                  05/09/2023 21:06:00 PAGE 8   

 427   1              delay_ms(50);
 428   1              
 429   1              LCD_Init();
 430   1              UartInit();
 431   1      
 432   1              Timer0Init();
 433   1              delay_ms(50);
 434   1      
 435   1              LCD_Fill(0,0,320,240,WHITE);
 436   1              printf("system begin\r");
 437   1              delay_ms(50);
 438   1              while(1)
 439   1              {
 440   2                      shurulvbo();
 441   2                  keyallchuli();
 442   2                      delay_ms(1);
 443   2                      if(flagsetzhichange==1)
 444   2                      {
 445   3                              flagsetzhichange=0;
 446   3                              showdata();
 447   3                              rumtimes=0;
 448   3                      }
 449   2                      else
 450   2                      {
 451   3                              rumtimes++;
 452   3                      }
 453   2                      if(rumtimes++>500)
 454   2                      {
 455   3                              rumtimes=0;
 456   3                              getwendu();
 457   3                              showdata();
 458   3                      }
 459   2              }
 460   1      }
 461          int weishu1, weishu2, weishu3, weishu4;
 462          char buf1[100];
 463          int timeleft1, timeleft2, timeleft3, timeleft4;
 464          void chuankou1put(char c)
 465          {
 466   1              buf1[weishu1++] = c;
 467   1              if (weishu1 > 80)
 468   1                      weishu1 = 0;
 469   1              timeleft1 = 10;
 470   1      }
 471          // 写个通用的，懒得去改后面的了。先偷懒了。。。
 472          void getwendufromrsp(char *p)
 473          {
 474   1              char* index;
 475   1              int ans;
 476   1              index=strstr(p,"getwendu");
 477   1              if(index==0)
 478   1              {
 479   2                      return  ;
 480   2              }
 481   1              ans=atoi(index+strlen("getwendu"));
 482   1              if(ans==-1)
 483   1              {
 484   2                      return;
 485   2              }
 486   1              tmp=ans;
 487   1      }
 488          void chuankou1jisuan()
C51 COMPILER V9.05   MAIN                                                                  05/09/2023 21:06:00 PAGE 9   

 489          {
 490   1              getwendufromrsp(buf1);
 491   1              memset(buf1, 0, sizeof(buf1));
 492   1              weishu1 = 0;
 493   1      }
 494          void chuankou1time()
 495          {
 496   1              if (timeleft1 > 0)
 497   1              {
 498   2                      timeleft1--;
 499   2                      if (timeleft1 == 0) // 数据一次收完了.
 500   2                      {
 501   3                              chuankou1jisuan();
 502   3                      }
 503   2              }
 504   1      }
 505          
 506          // 采用中断和处理分开的方式吧，方便调试。。
 507          void getwendu()
 508          {
 509   1              delay_ms(10);
 510   1              printf("getwendu");
 511   1              delay_ms(40);
 512   1      }
 513          void UartIsr() interrupt 4
 514          {
 515   1      
 516   1              if (RI)
 517   1              {
 518   2                      RI = 0;
 519   2                      chuankou1put(SBUF);
 520   2              }
 521   1      }
 522          
 523          void tm0_isr() interrupt 1
 524          {
 525   1              chuankou1time();
 526   1      }
 527          
 528          
 529          
 530          
 531          
 532          
 533          
 534          
 535          
 536          
 537          
 538          
 539          
 540          
 541          
 542          
 543          
 544          
 545          
 546          
 547          
 548          


C51 COMPILER V9.05   MAIN                                                                  05/09/2023 21:06:00 PAGE 10  

MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2230    ----
   CONSTANT SIZE    =   3520    ----
   XDATA SIZE       =    237     284
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
