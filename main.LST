C51 COMPILER V9.05   MAIN                                                                  05/06/2023 22:39:39 PAGE 1   


C51 COMPILER V9.05, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c LARGE BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include "STC8G.h"
   2          #include <intrins.h>
   3          #include <stdio.h>
   4          #include "lcd.h"
   5          #define u8 unsigned char
   6          #define FOSC 11059200UL
   7          #define BRT (65536 - FOSC / 9600 / 4)
   8          bit busy;
   9          void UartInit() // 11.0592 9600
  10          {
  11   1              SCON = 0x50;  // 8位数据,可变波特率
  12   1              AUXR |= 0x40; // 定时器时钟1T模式
  13   1              AUXR &= 0xFE; // 串口1选择定时器1为波特率发生器
  14   1              TMOD &= 0x0F; // 设置定时器模式
  15   1              TL1 = 0xE0;       // 设置定时初始值
  16   1              TH1 = 0xFE;       // 设置定时初始值
  17   1              ET1 = 0;          // 禁止定时器%d中断
  18   1              TR1 = 1;          // 定时器1开始计时
  19   1              ES = 1;
  20   1              EA = 1;
  21   1              P_SW1 = 0x00; // RXD/P3.0, TXD/P3.1
  22   1              //  P_SW1 = 0x40;                               //RXD_2/P3.6, TXD_2/P3.7
  23   1              //  P_SW1 = 0x80;                               //RXD_3/P1.6, TXD_3/P1.7
  24   1              //      PS=1;
  25   1      }
  26          void UartSendByte(u8 dat)
  27          {
  28   1              SBUF = dat;
  29   1              while (TI == 0)
  30   1                      ;
  31   1              TI = 0;
  32   1      }
  33          char putchar (char dat)
  34          {
  35   1              SBUF = dat;
  36   1              while (TI == 0)
  37   1                      ;
  38   1              TI = 0;
  39   1              return (SBUF = dat);
  40   1      }
  41          
  42          void UartSendStr(u8 *str)
  43          {
  44   1              while (*str)
  45   1              {
  46   2                      UartSendByte(*str);
  47   2                      str++;
  48   2              }
  49   1      }
  50          void Uart2Init()
  51          {
  52   1              S2CON = 0x10;
  53   1              T2L = BRT;
  54   1              T2H = BRT >> 8;
  55   1              AUXR |= 0x14;
C51 COMPILER V9.05   MAIN                                                                  05/06/2023 22:39:39 PAGE 2   

  56   1              IE2 = 0x01;
  57   1              EA = 1;
  58   1      }
  59          void Uart2Send(char dat)
  60          {
  61   1              while (busy)
  62   1                      ;
  63   1              busy = 1;
  64   1              S2BUF = dat;
  65   1      }
  66          
  67          void Uart2SendStr(char *p)
  68          {
  69   1              while (*p)
  70   1              {
  71   2                      Uart2Send(*p++);
  72   2              }
  73   1      }
  74          
  75          
  76          void Timer0Init(void) // 2毫秒@11.0592MHz
  77          {
  78   1              AUXR |= 0x80; // 定时器时钟1T模式
  79   1              TMOD &= 0xF0; // 设置定时器模式
  80   1              TL0 = 0x9a;       // 设置定时初值
  81   1              TH0 = 0xa9;       // 设置定时初值
  82   1              TF0 = 0;          // 清除TF0标志
  83   1              TR0 = 1;          // 定时器0开始计时
  84   1              TR0 = 1;          // 定时器0开始计时
  85   1              ET0 = 1;          // 使能定时器0中断
  86   1              PT0 = 1;
  87   1              EA = 1;
  88   1              //    IT0 = 1;                                    //??INT0?????
  89   1              //    EX0 = 1;                                    //??INT0??
  90   1              //    EA = 1;
  91   1              //
  92   1              //      IT1 = 1;                                    //??INT1?????
  93   1              //    EX1 = 1;                                    //??INT1??
  94   1              //    EA = 1;
  95   1      }
  96          
  97          
  98          
  99          
 100          
 101          
 102          
 103          sbit X0 = P2 ^ 3;
 104          sbit X1 = P2 ^ 1;
 105          sbit X2 = P3 ^ 7;
 106          sbit X3 = P3 ^ 5;
 107          
 108          
 109          sbit LED0 = P3 ^ 4;
 110          char xin[30]={0};
 111          void shurulvbo(void)
 112          {
 113   1              static u8 keybuf[40] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
 114   1                                                         0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
 115   1                                                         0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
 116   1                                                                                                                                                               0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
 117   1                                                        }; //矩阵按键扫描缓冲区 8ms
C51 COMPILER V9.05   MAIN                                                                  05/06/2023 22:39:39 PAGE 3   

 118   1              unsigned char i;
 119   1              // i=X0;
 120   1              // keybuf[0]=i;
 121   1              // i=X1;
 122   1              // keybuf[1]=i;
 123   1              //  i=X2;
 124   1              //  keybuf[2]=i;
 125   1              //   i=X3;
 126   1              //  keybuf[3]=i;
 127   1              i=X0;
 128   1              keybuf[0] = (keybuf[0] << 1) | i;
 129   1              i=X1;
 130   1              keybuf[1] = (keybuf[1] << 1) | i;
 131   1              i=X2;
 132   1              keybuf[2] = (keybuf[2] << 1) | i;
 133   1              i=X3;
 134   1              keybuf[3] = (keybuf[3] << 1) | i;
 135   1              for (i = 0; i < 10; i++) // 3按键，所以循环3次
 136   1              {
 137   2                      if ((keybuf[i] & 0xFF) == 0x00)
 138   2                      {
 139   3                              xin[i] = 0;
 140   3                      }
 141   2                      else if ((keybuf[i] & 0xFF) == 0xFF)
 142   2                      { // 连续3次扫描值为1，即1*8ms内都是弹起状态时，可认为按键已稳定的弹起
 143   3                              xin[i] = 1;
 144   3                      }
 145   2              }
 146   1      }
 147          void keydown(int i) // 按键按下的处理、、、
 148          {
 149   1              printf("keydown %d\r\n", i);
 150   1              if(i==0)
 151   1              {
 152   2                      LED0=~LED0;
 153   2              }
 154   1      }
 155          void keyallchuli()
 156          {
 157   1              int i;
 158   1              static int flag[10]={0};//标志记录
 159   1              for( i=0;i<6;i++)
 160   1              {
 161   2                      if(xin[i]==0)
 162   2                      {
 163   3                              if(flag[i]==0)//代表按键第一次按下。。。
 164   3                              {
 165   4                                      flag[i]=1;
 166   4                                      keydown(i);
 167   4                              }
 168   3                      }
 169   2                      else 
 170   2                              flag[i]=0;
 171   2              }
 172   1      }
 173          #define LCD_W 240
 174          #define LCD_H 320
 175          
 176          void main()
 177          {
 178   1                P0M0 = 0x00;
 179   1          P0M1 = 0x02;
C51 COMPILER V9.05   MAIN                                                                  05/06/2023 22:39:39 PAGE 4   

 180   1          P1M0 = 0x00;
 181   1          P1M1 = 0x00;
 182   1          P2M0 = 0x00;
 183   1          P2M1 = 0x00;
 184   1          P3M0 = 0x00;
 185   1          P3M1 = 0x00;
 186   1          P4M0 = 0x00;
 187   1          P4M1 = 0x00;
 188   1          P5M0 = 0x00;
 189   1          P5M1 = 0x00;
 190   1              
 191   1               SPCTL = 0x50|0x80;                               //??SPI????
 192   1          SPSTAT = 0xc0;                              //?????
 193   1              LCD_LED=0;
 194   1              delay_ms(100);
 195   1              
 196   1      //      SPI_Init();
 197   1              LCD_Init();
 198   1              // UartInit();
 199   1      
 200   1              // Timer0Init();
 201   1              delay_ms(100);
 202   1              // printf("123testruning");
 203   1              // printf("xxxx");
 204   1      
 205   1              LCD_Fill(0,0,LCD_W,LCD_H,BLUE);
 206   1              delay_ms(100);
 207   1              while(1)
 208   1              {
 209   2      
 210   2                      // LCD_ShowChinese(0,0,"中景园电子",RED,WHITE,32,0);
 211   2                      // LCD_ShowString(0,40,"LCD_W:",RED,WHITE,16,0);
 212   2                      LCD_ShowIntNum(48,40,LCD_W,3,RED,WHITE,16);
 213   2                      LCD_ShowString(80,40,"LCD_H:",RED,WHITE,16,0);
 214   2                      // LCD_ShowIntNum(128,40,LCD_H,3,RED,WHITE,16);
 215   2                      // LCD_ShowString(80,40,"LCD_H:",RED,WHITE,16,0);
 216   2                      // LCD_ShowString(0,70,"Increaseing Nun:",RED,WHITE,16,0);
 217   2                      delay_ms(300);
 218   2                      // LCD_ShowString(0,40,"LCD_W:",RED,WHITE,16,0);
 219   2                      // shurulvbo();
 220   2                      // keyallchuli();
 221   2                      // delay_ms(2);
 222   2                      // LCD_Clear(WHITE);
 223   2                      // delay_ms(300);
 224   2                      // LCD_Clear(RED);
 225   2                      // delay_ms(300);
 226   2                      // LCD_Clear(BLUE);
 227   2                      // delay_ms(300);
 228   2                      // LCD_Clear(GREEN);
 229   2                      // delay_ms(300);
 230   2                      // UartSendStr("123testruning");
 231   2              }
 232   1      }
 233          
 234          
 235          void UartIsr() interrupt 4
 236          {
 237   1      
 238   1              if (RI)
 239   1              {
 240   2                      RI = 0;
 241   2              }
C51 COMPILER V9.05   MAIN                                                                  05/06/2023 22:39:39 PAGE 5   

 242   1      }
 243          
 244          void tm0_isr() interrupt 1
 245          {
 246   1              
 247   1      }
 248          
 249          
 250          
 251          
 252          
 253          
 254          
 255          
 256          
 257          
 258          
 259          
 260          
 261          
 262          
 263          
 264          
 265          
 266          
 267          
 268          
 269          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    620    ----
   CONSTANT SIZE    =     20    ----
   XDATA SIZE       =     90       7
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
